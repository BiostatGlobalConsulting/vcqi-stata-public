*! make_tables_from_svyp_output version 1.05 - Biostat Global Consulting - 2016-03-10
*******************************************************************************
* Change log
* 				Updated
*				version
* Date 			number 	Name			What Changed
* 2016-01-18	1.01	Dale Rhoda		Changed to vcqi_global
* 2016-02-12	1.02	Dale Rhoda		Add TO to the list of temp datasets
* 										to possibly be deleted later, per the
* 										user's request
* 2016-02-26	1.03	Dale Rhoda		Switch FOOTNOTE code to while loop
* 2016-03-07	1.04	Dale Rhoda		Allow spaces in `sheet' via _nospaces
* 2016-03-10	1.05	Dale Rhoda		move most log_comments to DEBUG mode
* 2017-01-30	1.06	Dale Rhoda		Small formatting changes to implement
*										VCQI_LEVEL4_SET_VARLIST & VCQI_LEVEL4_SET_LAYOUT
* 2017-05-16	1.07	Dale Rhoda		Allow user to put stderr in the table
*******************************************************************************

program define make_tables_from_svyp_output

	syntax  , VARiables(string) ESTLABel(string asis) ///
	          VID(string) MEASureid(string) SHEET(string)
				
	local oldvcp $VCP
	global VCP make_tables_from_svyp_output
	
	quietly {
	
		local sheet_nospaces = subinstr("`sheet'"," ","_",.)

		vcqi_log_comment $VCP 5 Flow "Starting"	
		if "$VCQI_DEBUG" == "1" vcqi_log_comment $VCP 3 Comment "Worksheet = `sheet'"
		if "$VCQI_DEBUG" == "1" vcqi_log_comment $VCP 3 Comment "Variable = `variables'"
		if "$VCQI_DEBUG" == "1" vcqi_log_comment $VCP 3 Comment "VID = `vid'"


		* This program does several things...
		*
		* 1. It reads in the results generated by GO and tidies them up.
		* 2. It parses out what order the user wants to see stratum-level
		*    results in the spreadsheets.
		* 3. Then it writes (posts) the output to a new dataset in a format
		*    that looks like the tables...in the correct order and with
		*    blank rows, etc.  Nothing is formatted, but at this point it
		*    is staged for export to Excel.
		* 4. Then the program writes the table out to Excel and does some
		*    basic formatting.  
		*   
		*  (This sounds like too many jobs for one program, so consider
		*   coming back and breaking it into smaller pieces.)
		*	
		
		* open the post file with the handle name "to_dataset" (tabulated output)
		*
		* the three fields at the end: block level and substratum
		* are not meant to be written out, but are handy for formatting the 
		* spreadsheet cells
		*
		capture postclose to_dataset

		postfile to_dataset str50 stratum  estimate stderr str15 ci ///
					lcb  ucb  deff ///
					icc  n  nwtd ///
					block  level substratum ///
					using ///
					"${VCQI_OUTPUT_FOLDER}/`measureid'_${ANALYSIS_COUNTER}_`vid'_TO", replace

		global `measureid'_TEMP_DATASETS ${`measureid'_TEMP_DATASETS} `measureid'_${ANALYSIS_COUNTER}_`vid'_TO
		
		use "${VCQI_OUTPUT_FOLDER}/`measureid'_${ANALYSIS_COUNTER}_`vid'_database", clear
		
		* Preperatory work and tidying of variables	
			
		* calculate maximum number of characters in the stratum name
		gen stratum_name_length = length(name)
		qui summarize stratum_name_length
		local max_stratum_name_length = r(max)
		drop stratum_name_length
		
		* scale coverage figures up by 100x
		foreach v in estimate stderr cill ciul lcb ucb {
			replace `v' = `v' * 100
		}
		
		replace nwtd = round(nwtd,1)
		replace n = round(n,1)
		
		* generate a new 0/1 flag that indicates which rows in the output 
		* are showing results for sub-strata defined by level 4
		
		gen substratum = !missing(level4id)
		
		* generate the confidence interval string
		gen ci = "(" + strofreal(cill,"%03.1f") + ", " + strofreal(ciul,"%04.1f") + ")"
		replace ci = subinstr(ci,"100.0","100",1)
		replace ci = subinstr(ci,", 00.",", 0.",1)
		replace ci = "" if missing(cill)
		
		* bring in information about what order the user wants to list rows from
		* levels 2, 3, and 4.  If the user has NOT specifed datasets with sort 
		* order, then they are simply listed in numerical or alphabetical order 
		* of their respective ids
		
		if "$LEVEL2_ORDER_DATASET" != "" {
			merge m:1 level2id using "$LEVEL2_ORDER_DATASET"
			keep if _merge == 1 | _merge == 3
			drop _merge
			order level2order, after(level2id)
		}
		else {
			gen level2order = level2id
		}
		replace level2order = 0 if missing(level2order)
		
		if "$LEVEL3_ORDER_DATASET" != "" {
			merge m:1 level3id using "$LEVEL3_ORDER_DATASET"
			keep if _merge == 1 | _merge == 3
			drop _merge
			order level3order, after(level3id)
		}
		else {
			gen level3order = level3id
		}
		replace level3order = 0 if missing(level3order)

		if "$VCQI_LEVEL4_STRATIFIER" != "" & "$LEVEL4_ORDER_DATASET" != "" {
			merge m:1 level4id using "$LEVEL4_ORDER_DATASET"
			keep if _merge == 1 | _merge == 3
			drop _merge
		}
		else if "$VCQI_LEVEL4_SET_LAYOUT" != "" {
			* Use the level4_layout order as the level4order
			gen level4order = int(level4id)
		}
		else {
			gen level4order = level4id
		}
		replace level4order = 0 if missing(level4order)
		order level4order, after(level4id)
		
		***********************************************************
		*
		* Now we have eight blocks of code to generate different 
		* types of blocks of output.  The user might select only
		* one of these, or a subset.  It would probably be unusual 
		* to ask for all 8 blocks to be put out, as that would be
		* quite repetitive, but the code will happily do it if the
		* user asks for it.
		*
		* What people select will depend on what they are doing
		* with the tables and what sort of detail they want.
		*
		***********************************************************

		* In many cases the output tables will be easier to read if they
		* have a blank row between blocks and even within blocks between
		* large strata.  If the user asks for blanks between levels, then
		* we set up an empty post command to put out an empty row.
		*
		* Store the command in a local macro so we can call it later by
		* simply saying `postblankrow'.
		
		if $SHOW_BLANKS_BETWEEN_LEVELS == 1 {
			local postblankrow post to_dataset ("") (.) (.) ("") (.) (.) (.) (.) (.) (.) (.) (.) (.)
		}
		if $SHOW_BLANKS_BETWEEN_LEVELS == 0 {
			local postblankrow local noblankrows
		}
			

		* Only show results that are aggregated up to the national level (1)
		if $SHOW_LEVEL_1_ALONE == 1 {
			preserve 
			keep if level == 1 & missing(level4id)
			local i 1
			post to_dataset (name[`i']) (estimate[`i']) (stderr[`i']) (ci[`i']) (lcb[`i']) (ucb[`i']) ///
					(deff[`i']) (icc[`i']) (n[`i']) (nwtd[`i']) ///
					(1) (1) (0)
			restore
			if $SHOW_BLANKS_BETWEEN_LEVELS == 1 `postblankrow' 
		}
		
		* In this block we only show the sub-national or province level (2) results
		if $SHOW_LEVEL_2_ALONE == 1 {
			preserve
			keep if level == 2 & missing(level4id)
			sort level2order
			forvalues i = 1/`=_N' {
				post to_dataset (name[`i']) (estimate[`i']) (stderr[`i']) (ci[`i']) (lcb[`i']) (ucb[`i']) ///
						(deff[`i']) (icc[`i']) (n[`i']) (nwtd[`i']) ///
						(2) (level[`i']) (substratum[`i'])
			}
			restore
			if $SHOW_BLANKS_BETWEEN_LEVELS == 1 `postblankrow' 
		}

			
		* Only show the sub-sub-national level (3) without aggregating upward	
		if $SHOW_LEVEL_3_ALONE == 1 {
			preserve
			keep if level == 3 & missing(level4id)
			sort level3order
			forvalues i = 1/`=_N' {
				post to_dataset (name[`i']) (estimate[`i']) (stderr[`i']) (ci[`i']) (lcb[`i']) (ucb[`i']) ///
						(deff[`i']) (icc[`i']) (n[`i']) (nwtd[`i']) ///
						(3) (level[`i']) (substratum[`i'])
			}
			restore
			if $SHOW_BLANKS_BETWEEN_LEVELS == 1 `postblankrow' 
		}
		
		* Show each level 2 stratum (sorted in the order the user asked for)
		* and underneath the level 2 row, list one row for each of the level 3
		* strata that are in the level 2 stratum.  e.g., Show a row for each
		* province and then show a row for each district within the province.  
		*
		* After showing all districts for the first province, (optionally) post
		* a blank row and then post results for the next province and its districts
		if $SHOW_LEVELS_2_3_TOGETHER == 1 {
			preserve
			keep if inlist(level,2,3) & missing(level4id)
			sort level2order level3order
			forvalues i = 1/`=_N' {
				if `i' > 1 & level3order[`i'] == 0 `postblankrow'

				post to_dataset (name[`i']) (estimate[`i']) (stderr[`i']) (ci[`i']) (lcb[`i']) (ucb[`i']) ///
						(deff[`i']) (icc[`i']) (n[`i']) (nwtd[`i']) ///
						(4) (level[`i']) (substratum[`i'])
			}
			restore
			if $SHOW_BLANKS_BETWEEN_LEVELS == 1 `postblankrow' 
		}

		* Show national results along with the sub-strata (e.g., urban/rural)
		if $SHOW_LEVELS_1_4_TOGETHER == 1 {
			preserve
			keep if inlist(level,1) 
			sort level4order
			forvalues i = 1/`=_N' {
				if `i' > 1 & level4order[`i'] == 0 `postblankrow'

				post to_dataset (name[`i']) (estimate[`i']) (stderr[`i']) (ci[`i']) (lcb[`i']) (ucb[`i']) ///
						(deff[`i']) (icc[`i']) (n[`i']) (nwtd[`i']) ///
						(5) (level[`i']) (substratum[`i'])
			}
			restore
			if $SHOW_BLANKS_BETWEEN_LEVELS == 1 `postblankrow' 
		}

		* Show sub-national results along with substrata in each sub-national stratum
		* e.g., each province and then that province's results broken out by 
		* urban/rural
		if $SHOW_LEVELS_2_4_TOGETHER == 1 {
			preserve
			keep if inlist(level,2) 
			sort level2order level4order
			forvalues i = 1/`=_N' {
				if `i' > 1 & level4order[`i'] == 0 `postblankrow'

				post to_dataset (name[`i']) (estimate[`i']) (stderr[`i']) (ci[`i']) (lcb[`i']) (ucb[`i']) ///
						(deff[`i']) (icc[`i']) (n[`i']) (nwtd[`i']) ///
						(6) (level[`i']) (substratum[`i'])
			}
			restore
			if $SHOW_BLANKS_BETWEEN_LEVELS == 1 `postblankrow' 
		}
		
		* Show each level 3 stratum and then disaggregate it by the level 4 
		* stratifier (e.g., each district's results and then the district 
		* results broken out by urban/rural
		if $SHOW_LEVELS_3_4_TOGETHER == 1 {
			preserve
			keep if inlist(level,3) 
			sort level3order level4order
			forvalues i = 1/`=_N' {
				if `i' > 1 & level4order[`i'] == 0 `postblankrow'

				post to_dataset (name[`i']) (estimate[`i']) (stderr[`i']) (ci[`i']) (lcb[`i']) (ucb[`i']) ///
						(deff[`i']) (icc[`i']) (n[`i']) (nwtd[`i']) ///
						(7) (level[`i']) (substratum[`i'])
			}
			restore
			if $SHOW_BLANKS_BETWEEN_LEVELS == 1 `postblankrow' 
		}
		
		* Show the level 2 stratum results at the top of a block, then break it down
		* urban/rural; then show the first level 3 stratum within the level 2 
		* stratum and break THAT down urban/rural...show the next level 3 stratum
		* and break it down, until all level 3 strata in this level 2 stratum have
		* been listed.  Then skip a row and move on to the next level 2 stratum.
		if $SHOW_LEVELS_2_3_4_TOGETHER == 1 {
			preserve
			keep if inlist(level,2,3) 
			sort level2order level3order level4order
			forvalues i = 1/`=_N' {
				if `i' > 1 & level[`i'] == 2 & level4order[`i'] == 0 `postblankrow'

				post to_dataset (name[`i']) (estimate[`i']) (stderr[`i']) (ci[`i']) (lcb[`i']) (ucb[`i']) ///
						(deff[`i']) (icc[`i']) (n[`i']) (nwtd[`i']) ///
						(8) (level[`i']) (substratum[`i'])
			}
			restore
		}

		capture postclose to_dataset
		
		* Now the table should look pretty good in the to_dataset.
		* Do a little housecleaning and then export it to Excel.
		
		use "${VCQI_OUTPUT_FOLDER}/`measureid'_${ANALYSIS_COUNTER}_`vid'_TO", clear
		label variable estimate `"`estlabel'"'
		qui compress
		save, replace
		
		*******************************************************
		*
		* Now export the table to Excel
		*
		*
		
		* calculate number of rows in the table
		qui count
		local nrows = r(N)
		
		* for now we leave two blank rows at the top for title and subtitle
		local startrow 3
		local rows 4,`=`startrow'+`nrows''
		
		if "$VCQI_DEBUG" == "1" vcqi_log_comment $VCP 3 Comment "LAST_COL flex == ${LC4_`sheet_nospaces'}"

		* If we have not yet written to this tab, be sure to include the
		* stratum names in the output, and start at column 1
		if "${LC4_`sheet_nospaces'}" == "" {
			local nextcolumn 1
			local sheetoption sheetreplace
			if word("`variables'",1) != "stratum" local variables stratum `variables'		
		}
		else {
			local nextcolumn = `=${LC4_`sheet_nospaces'} + 1'
			local sheetoption sheetmodify
		}		
		
		* check for a valid list of variables
		foreach v in `variables' {
			if !inlist("`v'","stratum","estimate","stderr","ci") & ///
			   !inlist("`v'","lcb","ucb","deff","icc","n","nwtd") {
				di as error "make_tables_from_svyp_output.ado: The variable `v' is not one of the output options."
				di as error "Options include: stratum, estimate, stderr, ci, lcb, ucb, deff, icc, n, nwtd"
				vcqi_halt_immediately
			}
		}

		* how many variables are being exported?
		local nvars = wordcount("`variables'")
		
		if "$VCQI_DEBUG" == "1" vcqi_log_comment $VCP 3 Comment "variable list to export = `variables'"
		
		* which columns will they be written to?
		local cols `nextcolumn',`=`nextcolumn'+`nvars'-1'
				
		* what is the letter of the first column?
		vcqi_excel_convert_to_letter `nextcolumn'
		
		* what is the cell to put the upper left corner of the new export?
		local cell `r(ConvertToLetter)'`startrow'
		
		if "$VCQI_DEBUG" == "1" vcqi_log_comment $VCP 3 Comment "cell = `cell'"
				
		* Export the requested variables
		
		export excel `variables' using ///
			"${VCQI_OUTPUT_FOLDER}/${VCQI_ANALYSIS_NAME}_TO.xlsx", ///
			sheet("`sheet'") firstrow(variable) cell(`cell') ///
			`sheetoption'

		* update the global variable that records the last column to
		* which we exported data
		if "${LC4_`sheet_nospaces'}" == "" {
			vcqi_global LC4_`sheet_nospaces' `nvars'
		}
		else {
			vcqi_global LC4_`sheet_nospaces' `=${LC4_`sheet_nospaces'} + `nvars''	
		}	
		
		
		* Use mata to populate column labels and worksheet titles and footnotes
		mata: b = xl()
		mata: b.load_book("${VCQI_OUTPUT_FOLDER}/${VCQI_ANALYSIS_NAME}_TO.xlsx")
		mata: b.set_mode("open")
		mata: b.set_sheet("`sheet'")
		
		*Overwrite the stratum variable name...it is not needed
		mata: b.put_string(`startrow',1,"")

		forvalues i = 1/`nvars' {
			
			local col = `nextcolumn' - 1 + `i'
			
			if word("`variables'",`i') == "estimate" mata: b.put_string(`startrow',`col',"`estlabel'")
			if word("`variables'",`i') == "stderr" 	 mata: b.put_string(`startrow',`col',"StdErr (%)")
			if word("`variables'",`i') == "ci" 		 mata: b.put_string(`startrow',`col',"95% CI (%)")
			if word("`variables'",`i') == "lcb" 	 mata: b.put_string(`startrow',`col',"95% LCB (%)")
			if word("`variables'",`i') == "ucb" 	 mata: b.put_string(`startrow',`col',"95% UCB (%)")
			if word("`variables'",`i') == "deff" 	 mata: b.put_string(`startrow',`col',"DEFF")
			if word("`variables'",`i') == "icc" 	 mata: b.put_string(`startrow',`col',"ICC")
			if word("`variables'",`i') == "n" 		 mata: b.put_string(`startrow',`col',"N")
			if word("`variables'",`i') == "nwtd"  	 mata: b.put_string(`startrow',`col',"Weighted N")

		}
		
		* If this is the first time we are writing to the worksheet
		* include the measure titles and footnotes
		
		if `nextcolumn' == 1 {
			
			if "$`measureid'_TO_TITLE"    != "" {
				mata: b.put_string(1,1,"$`measureid'_TO_TITLE")
				mata: b.set_font_bold(1,1,"on")
			}
			
			if "${`measureid'_TO_SUBTITLE}" != "" mata: b.put_string(2,1,"${`measureid'_TO_SUBTITLE}")

			local footnoterow = `=`startrow'+`nrows'+2'
			local i 1
			while "${`measureid'_TO_FOOTNOTE_`i'}" != "" {
				mata: b.put_string(`footnoterow',1,"${`measureid'_TO_FOOTNOTE_`i'}")
				local ++footnoterow
				local ++i
			}
		}
		
		* Usually we'll want to format the excel, but it is time consuming
		* so give an option to turn that off during testing of the code
		if "$FORMAT_EXCEL" == "1" {
		
			* format individual fields to look good
			
			forvalues i = 1/`nvars' {
			
				local col = `nextcolumn' - 1 + `i'
			
				if word("`variables'",`i') == "stratum"  {
					mata: b.set_column_width(`col',`col', `=`max_stratum_name_length'+3')
					mata: b.set_horizontal_align((`rows'),`col',"left") 
				}
				
				if word("`variables'",`i') == "estimate" {
					mata: b.set_column_width(`col',`col', `=max(5,length("`estlabel'")+1)')
					mata: b.set_number_format((`rows'),`col',"##0.0;;0.0;")
				}
				
				if word("`variables'",`i') == "ci" {
					mata: b.set_column_width(`col',`col', 12)
					mata: b.set_horizontal_align((`rows'),`col',"right")
				}
				
				if word("`variables'",`i') == "lcb" | word("`variables'",`i') == "ucb" | word("`variables'",`i') == "stderr" {
					mata: b.set_column_width(`col',`col', 12)
					mata: b.set_number_format((`rows'),`col',"##0.0;;0.0;")
				}
				
				if word("`variables'",`i') == "deff" {
					mata: b.set_column_width(`col',`col', 5)
					mata: b.set_number_format((`rows'),`col',"0.0;-0.0;0;")
				}

				if word("`variables'",`i') == "icc" {
					mata: b.set_number_format((`rows'),`col',"0.###0;-0.###0;0;")
				}
				
				if word("`variables'",`i') == "n" {
					mata: b.set_column_width(`col',`col', 8)
					mata: b.set_number_format((`rows'),`col',"number_sep")
				}
				
				if word("`variables'",`i') == "nwtd" {
					mata: b.set_column_width(`col',`col', 12)
					mata: b.set_number_format((`rows'),`col',"number_sep")
				}
			}
			
			* right align column titles
			mata: b.set_horizontal_align(`startrow',(`cols'),"right")
			
			* add bold or shading or indent or italics
			forvalues j = 1/`=_N' {
		
				local i = `j' + `startrow'

				if block[`j'] == 4 & ///
				   level[`j'] == 2 ///
				   mata: b.set_fill_pattern(`i',(`cols'),"solid","lightgray")
				
				if block[`j'] == 8 & ///
				   level[`j'] == 2 & ///
				   substratum[`i'] == 0 ///
				   mata: b.set_fill_pattern(`i',(`cols'),"solid","lightgray")
				
				* Indent level 4 stratum names unless they are headings (LABEL_ONLY) with no estimate
				if `nextcolumn' == 1 & substratum[`j'] == 1 & !missing(estimate[`j']) ///
					mata: b.set_text_indent(`i',`nextcolumn',3)
				if `nextcolumn' == 1 & substratum[`j'] == 1 & missing(estimate[`j']) ///
					mata: b.set_text_indent(`i',`nextcolumn',1)
				if `nextcolumn' == 1 & substratum[`j'] == 1 ///
					mata: b.set_font_italic(`i',`nextcolumn',"on")
				
				if level[`j'] == 1 & ///
					substratum[`j'] == 0 mata: b.set_font_bold(`i',(`cols'),"on")
			}			
			
		}
		
		mata: b.close_book()
			
		vcqi_log_comment $VCP 3 Comment "Tabular output: `measureid' `estlabel' : `variables' to sheet `sheet' in ${VCQI_OUTPUT_FOLDER}/${VCQI_ANALYSIS_NAME}_TO.xlsx"	
	}
	
	vcqi_log_comment $VCP 5 Flow "Exiting"
	global VCP `oldvcp'

end
