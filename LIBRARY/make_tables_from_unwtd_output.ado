*! make_tables_from_unwtd_output version 1.06 - Biostat Global Consulting - 2017-08-26
*******************************************************************************
* Change log
* 				Updated
*				version
* Date 			number 	Name			What Changed
* 2016-01-18	1.01	Dale Rhoda		Changed to vcqi_global
* 2016-02-12	1.02	Dale Rhoda		Add TO to the list of temp datasets
* 										to possibly be deleted later, per the
* 										user's request
* 2016-02-26	1.03	Dale Rhoda		Switch FOOTNOTE code to while loop
* 2016-03-07	1.04	Dale Rhoda		Allow spaces in `sheet' via _nospaces
* 2017-01-30	1.05	Dale Rhoda		Small formatting changes to implement
*										VCQI_LEVEL4_SET_VARLIST & VCQI_LEVEL4_SET_LAYOUT
* 2017-08-26	1.06	Mary Prier		Added version 14.1 line
*******************************************************************************

program define make_tables_from_unwtd_output
	version 14.1
	
	syntax  , VARiable(string) ESTLABel(string asis) ///
	          VID(string) MEASureid(string) SHEET(string) [ noOMITpriorn RATIO ]
				
	local oldvcp $VCP
	global VCP make_tables_from_unwtd_output
	vcqi_log_comment $VCP 5 Flow "Starting"
	
	quietly {

		local sheet_nospaces = subinstr("`sheet'"," ","_",.)

		vcqi_log_comment $VCP 5 Flow "Starting"	
		if "$VCQI_DEBUG" == "1" vcqi_log_comment $VCP 3 Comment "Worksheet = `sheet'"
		if "$VCQI_DEBUG" == "1" vcqi_log_comment $VCP 3 Comment "Measure = `measureid'"
		if "$VCQI_DEBUG" == "1" vcqi_log_comment $VCP 3 Comment "Variable = `variable'"
		if "$VCQI_DEBUG" == "1" vcqi_log_comment $VCP 3 Comment "Label = `estlabel'"
		if "$VCQI_DEBUG" == "1" vcqi_log_comment $VCP 3 Comment "VID = `vid'"
		if "$VCQI_DEBUG" == "1" vcqi_log_comment $VCP 3 Comment "Omitpriorn = `omitpriorn'"
		if "$VCQI_DEBUG" == "1" vcqi_log_comment $VCP 3 Comment "Ratio = `ratio'"
		
		* This program does several things...
		*
		* 1. It reads in the results generated by GO and tidies them up.
		* 2. It parses out what order the user wants to see stratum-level
		*    results in the spreadsheets.
		* 3. Then it writes (posts) the output to a new dataset in a format
		*    that looks like the tables...in the correct order and with
		*    blank rows, etc.  Nothing is formatted, but at this point it
		*    is staged for export to Excel.
		* 4. Then the program writes the table out to Excel and does some
		*    basic formatting.
		*
		*   
		*  (This sounds like too many jobs for one program, so consider
		*   coming back and breaking it into smaller pieces.)
		
		* Open the post file with the handle name "to_dataset" (tabulated output)
		*
		* the three fields at the end: block level and substratum
		* are not meant to be written out, but are handy for formatting the 
		* spreadsheet cells
		*
		capture postclose to_dataset

		postfile to_dataset str50 stratum  estimate n block level substratum ///
					using ///
					"${VCQI_OUTPUT_FOLDER}/`measureid'_${ANALYSIS_COUNTER}_`vid'_TO", replace

		global `measureid'_TEMP_DATASETS ${`measureid'_TEMP_DATASETS} `measureid'_${ANALYSIS_COUNTER}_`vid'_TO

		use "${VCQI_OUTPUT_FOLDER}/`measureid'_${ANALYSIS_COUNTER}_`vid'_database", clear
		
		* Preperatory work and tidying of variables	
		
		* calculate maximum number of characters in the stratum name
		gen stratum_name_length = length(name)
		qui summarize stratum_name_length
		local max_stratum_name_length = r(max)
		drop stratum_name_length
		
		* scale estimate figures up by 100x if this is a percent and not a ratio
		replace estimate = estimate * 100 if "`ratio'" != "ratio"
		
		replace n = round(n,1)
		
		* generate a new 0/1 flag that indicates which rows in the output 
		* are showing results for sub-strata defined by level 4
		
		gen substratum = !missing(level4id)
		
		* bring in information about what order the user wants to list rows from
		* levels 2, 3, and 4.  If the user has NOT specifed datasets with sort 
		* order, then they are simply listed in numerical or alphabetical order 
		* of their respective ids
		
		if "$LEVEL2_ORDER_DATASET" != "" {
			merge m:1 level2id using "$LEVEL2_ORDER_DATASET"
			keep if _merge == 1 | _merge == 3
			drop _merge
			order level2order, after(level2id)
		}
		else {
			gen level2order = level2id
		}
		replace level2order = 0 if missing(level2order)
		
		if "$LEVEL3_ORDER_DATASET" != "" {
			merge m:1 level3id using "$LEVEL3_ORDER_DATASET"
			keep if _merge == 1 | _merge == 3
			drop _merge
			order level3order, after(level3id)
		}
		else {
			gen level3order = level3id
		}
		replace level3order = 0 if missing(level3order)

		if "$VCQI_LEVEL4_STRATIFIER" != "" & "$LEVEL4_ORDER_DATASET" != "" {
			merge m:1 level4id using "$LEVEL4_ORDER_DATASET"
			keep if _merge == 1 | _merge == 3
			drop _merge
		}
		else if "$VCQI_LEVEL4_SET_LAYOUT" != "" & "$LEVEL4_ORDER_DATASET" != "" {
			* Use the level4_layout order as the level4order
			gen level4order = int(level4id)
		}
		else {
			gen level4order = level4id
		}
		replace level4order = 0 if missing(level4order)
		order level4order, after(level4id)
		
		***********************************************************
		*
		* Now we have eight blocks of code to generate different 
		* types of blocks of output.  The user might select only
		* one of these, or a subset.  It would probably be unusual 
		* to ask for all 8 blocks to be put out, as that would be
		* quite repetitive, but the code will happily do it if the
		* user asks for it.
		*
		* What people select will depend on what they are doing
		* with the tables and what sort of detail they want.
		*
		***********************************************************

		* In many cases the output tables will be easier to read if they
		* have a blank row between blocks and even within blocks between
		* large strata.  If the user asks for blanks between levels, then
		* we set up an empty post command to put out an empty row.
		*
		* Store the command in a local macro so we can call it later by
		* simply saying `postblankrow'.
		
		if $SHOW_BLANKS_BETWEEN_LEVELS == 1 {
			local postblankrow post to_dataset ("") (.) (.) (.) (.) (.)
		}
		if $SHOW_BLANKS_BETWEEN_LEVELS == 0 {
			local postblankrow local noblankrows
		}

		* Only show results that are aggregated up to the national level (1)
		if $SHOW_LEVEL_1_ALONE == 1 {
			preserve 
			keep if level == 1 & missing(level4id)
			local i 1
			post to_dataset (name[`i']) (estimate[`i']) (n[`i'])  ///
					(1) (1) (0)
			restore
			if $SHOW_BLANKS_BETWEEN_LEVELS == 1 `postblankrow' 
		}
		
		* In this block we only show the sub-national or province level (2) results
		if $SHOW_LEVEL_2_ALONE == 1 {
			preserve
			keep if level == 2 & missing(level4id)
			sort level2order
			forvalues i = 1/`=_N' {
				post to_dataset (name[`i']) (estimate[`i']) (n[`i'])  ///
						(2) (level[`i']) (substratum[`i'])
			}
			restore
			if $SHOW_BLANKS_BETWEEN_LEVELS == 1 `postblankrow' 
		}

			
		* Only show the sub-sub-national level (3) without aggregating upward	
		if $SHOW_LEVEL_3_ALONE == 1 {
			preserve
			keep if level == 3 & missing(level4id)
			sort level3order
			forvalues i = 1/`=_N' {
				post to_dataset (name[`i']) (estimate[`i']) (n[`i'])  ///
						(3) (level[`i']) (substratum[`i'])
			}
			restore
			if $SHOW_BLANKS_BETWEEN_LEVELS == 1 `postblankrow' 
		}
		
		* Show each level 2 stratum (sorted in the order the user asked for)
		* and underneath the level 2 row, list one row for each of the level 3
		* strata that are in the level 2 stratum.  e.g., Show a row for each
		* province and then show a row for each district within the province.  
		*
		* After showing all districts for the first province, (optionally) post
		* a blank row and then post results for the next province and its districts
		if $SHOW_LEVELS_2_3_TOGETHER == 1 {
			preserve
			keep if inlist(level,2,3) & missing(level4id)
			sort level2order level3order
			forvalues i = 1/`=_N' {
				if `i' > 1 & level3order[`i'] == 0 `postblankrow'

				post to_dataset (name[`i']) (estimate[`i']) (n[`i']) ///
						(4) (level[`i']) (substratum[`i'])
			}
			restore
			if $SHOW_BLANKS_BETWEEN_LEVELS == 1 `postblankrow' 
		}

		* Show national results along with the sub-strata (e.g., urban/rural)
		if $SHOW_LEVELS_1_4_TOGETHER == 1 {
			preserve
			keep if inlist(level,1) 
			sort level4order
			forvalues i = 1/`=_N' {
				if `i' > 1 & level4order[`i'] == 0 `postblankrow'

				post to_dataset (name[`i']) (estimate[`i']) (n[`i']) ///
						(5) (level[`i']) (substratum[`i'])
			}
			restore
			if $SHOW_BLANKS_BETWEEN_LEVELS == 1 `postblankrow' 
		}

		* Show sub-national results along with substrata in each sub-national stratum
		* e.g., each province and then that province's results broken out by 
		* urban/rural
		if $SHOW_LEVELS_2_4_TOGETHER == 1 {
			preserve
			keep if inlist(level,2) 
			sort level2order level4order
			forvalues i = 1/`=_N' {
				if `i' > 1 & level4order[`i'] == 0 `postblankrow'

				post to_dataset (name[`i']) (estimate[`i']) (n[`i'])  ///
						(6) (level[`i']) (substratum[`i'])
			}
			restore
			if $SHOW_BLANKS_BETWEEN_LEVELS == 1 `postblankrow' 
		}
		
		* Show each level 3 stratum and then disaggregate it by the level 4 
		* stratifier (e.g., each district's results and then the district 
		* results broken out by urban/rural
		if $SHOW_LEVELS_3_4_TOGETHER == 1 {
			preserve
			keep if inlist(level,3) 
			sort level3order level4order
			forvalues i = 1/`=_N' {
				if `i' > 1 & level4order[`i'] == 0 `postblankrow'

				post to_dataset (name[`i']) (estimate[`i']) (n[`i']) ///
						(7) (level[`i']) (substratum[`i'])
			}
			restore
			if $SHOW_BLANKS_BETWEEN_LEVELS == 1 `postblankrow' 
		}
		
		* Show the level 2 stratum results at the top of a block, then break it down
		* urban/rural; then show the first level 3 stratum within the level 2 
		* stratum and break THAT down urban/rural...show the next level 3 stratum
		* and break it down, until all level 3 strata in this level 2 stratum have
		* been listed.  Then skip a row and move on to the next level 2 stratum.
		if $SHOW_LEVELS_2_3_4_TOGETHER == 1 {
			preserve
			keep if inlist(level,2,3) 
			sort level2order level3order level4order
			forvalues i = 1/`=_N' {
				if `i' > 1 & level[`i'] == 2 & level4order[`i'] == 0 `postblankrow'

				post to_dataset (name[`i']) (estimate[`i']) (n[`i']) ///
						(8) (level[`i']) (substratum[`i'])
			}
			restore
		}

		capture postclose to_dataset
		
		* Now the table should look pretty good in the to_dataset.
		* Do a little housecleaning and then export it to Excel.
		
		use "${VCQI_OUTPUT_FOLDER}/`measureid'_${ANALYSIS_COUNTER}_`vid'_TO", clear
		qui compress
		save, replace
		
		*******************************************************
		*
		* Export to Excel
		*
		
		* calculate number of rows in the table
		qui count
		local nrows = r(N)
		
		* for now we leave two blank rows at the top for title and subtitle
		local startrow 3
		local rows 4,`=`startrow'+`nrows''
		
		if "$VCQI_DEBUG" == "1" vcqi_log_comment $VCP 3 Comment "LAST_COL full == ${LC4_`sheet_nospaces'}"
		* If we have not yet written to this tab, be sure to include the
		* stratum names in the output, and start at column 1
		if "${LC4_`sheet_nospaces'}" == "" {
			local vlist stratum estimate n 
			local nextcolumn 1
			local sheetoption sheetreplace
			local stratum	1
			local estimate  2
			local n			3
		}
		* If we have already written something to this tab, then we do not
		* need to repeat the stratum names;  
		*
		* If the option noomitpriorn is set, then we move over one column from
		* where we last left off, so the N column from the last call will 
		* still show up in the output
		* 
		* If the option noomitpriorn is not set, then we overwrite the previous 
		* value of N with the new value of % (by starting in the same column
		* where we last left off).  But of course the value of N is written out
		* again by this operation, so if it is the last, the N will show, or if
		* the next call to this program does not specify omitpriorn then this
		* N column will also show in the final worksheet
		
		else {
			local vlist estimate n 
			* Assume that we wish to omit the earlier N
			local nextcolumn = `=${LC4_`sheet_nospaces'}'
			* Adjust nextcolumn if the user does NOT want to omit earlier N
			if "`omitpriorn'" == "noomitpriorn" local nextcolumn = `=${LC4_`sheet_nospaces'}+1'
			local sheetoption sheetmodify
			local estimate  `nextcolumn'
			local n			`=`nextcolumn'+1'
		}
		
		if "$VCQI_DEBUG" == "1" vcqi_log_comment $VCP 3 Comment "vlist = `vlist'"
		
		local cols `nextcolumn',`n'
				
		vcqi_excel_convert_to_letter `nextcolumn'
		
		local cell `r(ConvertToLetter)'`startrow'
		
		if "$VCQI_DEBUG" == "1" vcqi_log_comment $VCP 3 Comment "cell = `cell'"
				
		* Export the brief table to an Excel worksheet.  The user specifies the
		* name of the worksheet.
		export excel `vlist' using "${VCQI_OUTPUT_FOLDER}/${VCQI_ANALYSIS_NAME}_TO.xlsx", ///
		sheet("`sheet'") firstrow(variable) cell(`cell') `sheetoption'

		if "${LC4_`sheet_nospaces'}" == "" {
			vcqi_global LC4_`sheet_nospaces' 3
		}
		else {
			vcqi_global LC4_`sheet_nospaces' `=${LC4_`sheet_nospaces'} + 1 + ("`omitpriorn'" == "noomitpriorn")'	
		}	
		
		mata: b = xl()
		mata: b.load_book("${VCQI_OUTPUT_FOLDER}/${VCQI_ANALYSIS_NAME}_TO.xlsx")
		mata: b.set_mode("open")
		mata: b.set_sheet("`sheet'")
		
		*Overwrite the stratum variable name...it is not needed
		mata: b.put_string(`startrow',1,"")

		mata: b.put_string(`startrow',`estimate',"`estlabel'")
		mata: b.put_string(`startrow',`n',"N")
		
		if `nextcolumn' == 1 {
					
			if "$`measureid'_TO_TITLE"    != "" {
				mata: b.put_string(1,1,"$`measureid'_TO_TITLE")
				mata: b.set_font_bold(1,1,"on")
			}
			if "${`measureid'_TO_SUBTITLE}" != "" mata: b.put_string(2,1,"${`measureid'_TO_SUBTITLE}")

			local footnoterow = `=`startrow'+`nrows'+2'
			local i 1
			while "${`measureid'_TO_FOOTNOTE_`i'}" != "" {
				mata: b.put_string(`footnoterow',1,"${`measureid'_TO_FOOTNOTE_`i'}")
				local ++footnoterow
				local ++i
			}
		}
		
		if "$FORMAT_EXCEL" == "1" {
					
			if `nextcolumn' == 1 mata: b.set_column_width(`stratum',`stratum', `=`max_stratum_name_length'+3')
			if `nextcolumn' == 1 mata: b.set_horizontal_align((`rows'),`stratum',"left")

			mata: b.set_column_width(`estimate',`estimate', `=max(5,length("`estlabel'")+1)')
			if "`ratio'" != "ratio" mata: b.set_number_format((`rows'),`estimate',"##0.0;;0.0;")
			if "`ratio'" == "ratio" mata: b.set_number_format((`rows'),`estimate',"##0.000;;0.0;")

			mata: b.set_column_width(`n',`n'      ,  8)
			
			mata: b.set_number_format((`rows'),   `n',"number_sep")
		
			mata: b.set_horizontal_align(`startrow',(`cols'),"right")
			
			* add bold or shading or indent or italics
			forvalues j = 1/`=_N' {
		
				local i = `j' + `startrow'

				if block[`j'] == 4 & ///
				   level[`j'] == 2 ///
				   mata: b.set_fill_pattern(`i',(`cols'),"solid","lightgray")
				
				if block[`j'] == 8 & ///
				   level[`j'] == 2 & ///
				   substratum[`i'] == 0 ///
				   mata: b.set_fill_pattern(`i',(`cols'),"solid","lightgray")
				
				* Indent level 4 stratum names unless they are headings (LABEL_ONLY) with no estimate
				if `nextcolumn' == 1 & substratum[`j'] == 1 & !missing(estimate[`j']) ///
					mata: b.set_text_indent(`i',`nextcolumn',3)
				if `nextcolumn' == 1 & substratum[`j'] == 1 ///
					mata: b.set_font_italic(`i',`nextcolumn',"on")
				
				if level[`j'] == 1 & ///
					substratum[`j'] == 0 mata: b.set_font_bold(`i',(`cols'),"on")
			}	
		}		
		
		mata: b.close_book()
		
		vcqi_log_comment $VCP 3 Comment "Tabular output: `measureid' - `variable' to sheet `sheet' in ${VCQI_OUTPUT_FOLDER}/${VCQI_ANALYSIS_NAME}_TO.xlsx"	
	}
	
	vcqi_log_comment $VCP 5 Flow "Exiting"
	global VCP `oldvcp'

end
