*! make_tables_from_DESC_0203 version 1.10 - Biostat Global Consulting - 2020-12-12
*******************************************************************************
* Change log
* 				Updated
*				version
* Date 			number 	Name			What Changed
* 2016-02-12	1.01	Dale Rhoda		Add TO to the list of temp datasets
* 										to possibly be deleted later, per the
* 										user's request
* 2016-02-26	1.02	Dale Rhoda		Switch FOOTNOTE code to while loop
*										and changed pct label code to while loop
* 2017-01-31	1.03	Dale Rhoda		Generate LEVEL4 output using
*										VCQI_LEVEL4_SET_VARLIST & 
*										VCQI_LEVEL4_SET_LAYOUT
* 2017-03-09	1.04	Dale Rhoda		Change index logic to look for n
*										instead of pct1; pct1 can be missing
*										if there are no respondents in a
*										sub-group population
* 2017-03-26	1.05	Dale Rhoda		Allow user to :
*										a) put sub-total BEFORE a variable or response
*										b) put sub-total AFTER  a variable or response
*										c) show sub-totals only
* 2017-08-26	1.06	Mary Prier		Added version 14.1 line
* 2018-01-16	1.07	MK Trimner		Added label options for N and NWTD
* 2018-01-17	1.08	Dale Rhoda		Added capability to _LIST_N_BEFORE_PCT
* 										and to _LIST_NWTD_BEFORE_PCT
* 2020-01-07	1.09	MK Trimner		Added double quotes to get length to account for multi lingual
* 2020-01-09			MK Trimner		changed length for  col width for N and NWTD Labels to ustrlen to accomodate the multilingual globals
*										Removed double quotes for `vlabel`pcounter'' length
*										Added locals to capture the label length and pass through for col width for N and NWTD
* 2020-01-15			MK Trimner		Added locals and double quotes for `vlabel`pcounter'' col widths
* 2020-12-12	1.10	Dale Rhoda		Allow the user to SHOW_LEVEL_4_ALONE
*******************************************************************************

program define make_tables_from_DESC_0203
	version 14.1
	
	syntax ,  VID(string) MEASureid(string) SHEET(string)
				
	local oldvcp $VCP
	global VCP make_tables_from_DESC_0203

	vcqi_log_comment $VCP 5 Flow "Starting"	
	if "$VCQI_DEBUG" == "1" vcqi_log_comment $VCP 3 Comment "Worksheet = `sheet'"
	if "$VCQI_DEBUG" == "1" vcqi_log_comment $VCP 3 Comment "VID = `vid'"
	if "$VCQI_DEBUG" == "1" vcqi_log_comment $VCP 3 Comment "MeasureID = `measureid'"
	
	* This program does several things...
	*
	* 1. It reads in the results generated by GO and tidies them up.
	* 2. It parses out what order the user wants to see stratum-level
	*    results in the spreadsheets.
	* 3. Then it writes (posts) the output to a new dataset in a format
	*    that looks like the tables...in the correct order and with
	*    blank rows, etc.  Nothing is formatted, but at this point it
	*    is staged for export to Excel.
	* 4. Then the program writes the table out to Excel and does some
	*    basic formatting.  
	*   
	*  (This sounds like too many jobs for one program, so consider
	*   coming back and breaking it into smaller pieces.)
	*	
	
	* open the post file with the handle name "to_dataset" (tabulated output)
	*
	* the three fields at the end: block level and substratum
	* are not meant to be written out, but are handy for formatting the 
	* spreadsheet cells
	*

	* Build the lists of variables to post & if weighted, gen the CI vars
	
	use "${VCQI_OUTPUT_FOLDER}/`measureid'_${ANALYSIS_COUNTER}_`vid'_database", clear
	
	* Check to see if the table should include N before each pct
	if upper("${`measureid'_LIST_N_BEFORE_PCT}") == "YES" local list_n_first 1
	else local list_n_first 0
	
	* check the dataset to see if the calculation was weighted
	capture confirm variable nwtd
	if _rc == 0 local wtd 1
	if _rc != 0 local wtd 0
	
	* Check to see if the table should include weighted N before each pct
	* (Only possible if the measure is weighted)
	if `wtd' & upper("${`measureid'_LIST_NWTD_BEFORE_PCT}") == "YES" local list_nwtd_first 1
	else local list_nwtd_first 0
	
	* If the analysis is not weighted, include a column with n at the far right
	* If the analysis is weighted, also include nwtd
	replace n = round(n,1)
	*if `wtd' replace nwtd = round(nwtd,1)
	
	* check the dataset to see how many levels of pct there are
	* and store the label for each
		
	forvalues ii = 1/`=wordcount("${`measureid'_VORDER}")' {
		local i `=word("${`measureid'_VORDER}",`ii')'
				
		if `list_n_first' {
			local plist `plist' n`i'
			local blist `blist' (.)
			local xlist `xlist' (n`i'[|i'])
			gen n`i' = round(pct`i'*n)
			label variable n`i' `"`: variable label pct`i'' (N)"'
		}
		
		if `list_nwtd_first' {
			local plist `plist' double nwtd`i'
			local blist `blist' (.)
			local xlist `xlist' (nwtd`i'[|i'])
			gen double nwtd`i' = round(pct`i'*nwtd,0.1)
			label variable nwtd`i' `"`: variable label pct`i'' (Weighted N)"'
		}		
			
		local vlabel`ii' `: variable label pct`i''
		
		label variable pct`i' `"`: variable label pct`i'' (%)"'

		local plist `plist' double pct`i'
		if `wtd' local plist `plist' str25 ci`i'
		local blist `blist' (.)
		if `wtd' local blist `blist' ("")
		local xlist `xlist' (pct`i'[|i'])
		if `wtd' local xlist `xlist' (ci`i'[|i'])
		
		if `wtd' {
			replace cill`i' = cill`i'*100
			replace ciul`i' = ciul`i'*100
			gen ci`i' = "(" + strofreal(cill`i',"%03.1f") + ", " + strofreal(ciul`i',"%04.1f") + ")"
			replace ci`i' = subinstr(ci`i',"100.0","100",1)
			replace ci`i' = subinstr(ci`i',", 00.",", 0.",1)
			replace ci`i' = "" if missing(cill`i')
			order ci`i', after(pct`i')
			drop cill`i' ciul`i'
		}

		replace pct`i' = pct`i'*100
		
	}

	local nlist n
	local xlist `xlist' (n[|i'])
	
	if `wtd' local nlist n nwtd
	if `wtd' local xlist `xlist' (nwtd[|i'])

	local blist `blist' (.)
	if `wtd' local blist `blist' (.)
	
	save, replace
	
	capture postclose to_dataset
	
	* the variable 'outcome' is simply a placeholder for a label here...

	postfile to_dataset str50 stratum outcome `plist' `nlist' ///
				 block  level substratum ///
				using ///
				"${VCQI_OUTPUT_FOLDER}/`measureid'_${ANALYSIS_COUNTER}_`vid'_TO", replace

	global `measureid'_TEMP_DATASETS ${`measureid'_TEMP_DATASETS} `measureid'_${ANALYSIS_COUNTER}_`vid'_TO
	
	* Preparatory work and tidying of variables	
		
	* calculate maximum number of characters in the stratum name
	gen stratum_name_length = length(name)
	qui summarize stratum_name_length
	local max_stratum_name_length = r(max)
	drop stratum_name_length
	
	* generate a new 0/1 flag that indicates which rows in the output 
	* are showing results for sub-strata defined by level 4
	
	gen substratum = !missing(level4id)
		
	* bring in information about what order the user wants to list rows from
	* levels 2, 3, and 4.  If the user has NOT specifed datasets with sort 
	* order, then they are simply listed in numerical or alphabetical order 
	* of their respective ids
	
	if "$LEVEL2_ORDER_DATASET" != "" {
		merge m:1 level2id using "$LEVEL2_ORDER_DATASET"
		keep if _merge == 1 | _merge == 3
		drop _merge
		order level2order, after(level2id)
	}
	else {
		gen level2order = level2id
	}
	replace level2order = 0 if missing(level2order)
	
	if "$LEVEL3_ORDER_DATASET" != "" {
		merge m:1 level3id using "$LEVEL3_ORDER_DATASET"
		keep if _merge == 1 | _merge == 3
		drop _merge
		order level3order, after(level3id)
	}
	else {
		gen level3order = level3id
	}
	replace level3order = 0 if missing(level3order)

	if "$VCQI_LEVEL4_STRATIFIER" != "" & "$LEVEL4_ORDER_DATASET" != "" {
		merge m:1 level4id using "$LEVEL4_ORDER_DATASET"
		keep if _merge == 1 | _merge == 3
		drop _merge
	}
	else if "$VCQI_LEVEL4_SET_LAYOUT" != "" & "$LEVEL4_ORDER_DATASET" != "" {
		* Use the level4_layout order as the level4order
		gen level4order = int(level4id)
	}
	else {
		gen level4order = level4id
	}
	replace level4order = 0 if missing(level4order)
	order level4order, after(level4id)
	
	***********************************************************
	*
	* Now we have eight blocks of code to generate different 
	* types of blocks of output.  The user might select only
	* one of these, or a subset.  It would probably be unusual 
	* to ask for all 8 blocks to be put out, as that would be
	* quite repetitive, but the code will happily do it if the
	* user asks for it.
	*
	* What people select will depend on what they are doing
	* with the tables and what sort of detail they want.
	*
	***********************************************************

	* In many cases the output tables will be easier to read if they
	* have a blank row between blocks and even within blocks between
	* large strata.  If the user asks for blanks between levels, then
	* we set up an empty post command to put out an empty row.
	*
	* Store the command in a local macro so we can call it later by
	* simply saying `postblankrow'.
	
	if $SHOW_BLANKS_BETWEEN_LEVELS == 1 {
		local postblankrow post to_dataset ("") (.) `blist' (.) (.) (.)
	}
	if $SHOW_BLANKS_BETWEEN_LEVELS == 0 {
		local postblankrow local noblankrows
	}
	
	* now wrap the i in macro quotes before using xlist in the posts below
	local xlist = subinstr("`xlist'","|","\`",.)

	* Only show results that are aggregated up to the national level (1)
	if $SHOW_LEVEL_1_ALONE == 1 {
		preserve 
		keep if level == 1 & missing(level4id)
		local i 1
		post to_dataset (name[`i']) (.) `xlist' ///
				(1) (1) (0)
		restore
		if $SHOW_BLANKS_BETWEEN_LEVELS == 1 `postblankrow' 
	}
	
	* In this block we only show the sub-national or province level (2) results
	if $SHOW_LEVEL_2_ALONE == 1 {
		preserve
		keep if level == 2 & missing(level4id)
		sort level2order
		forvalues i = 1/`=_N' {
			post to_dataset (name[`i']) (.) `xlist' ///
					(2) (level[`i']) (substratum[`i'])
		}
		restore
		if $SHOW_BLANKS_BETWEEN_LEVELS == 1 `postblankrow' 
	}

		
	* Only show the sub-sub-national level (3) without aggregating upward	
	if $SHOW_LEVEL_3_ALONE == 1 {
		preserve
		keep if level == 3 & missing(level4id)
		sort level3order
		forvalues i = 1/`=_N' {
			post to_dataset (name[`i']) (.) `xlist' ///
					(3) (level[`i']) (substratum[`i'])
		}
		restore
		if $SHOW_BLANKS_BETWEEN_LEVELS == 1 `postblankrow' 
	}
	
		
	* Only show the sub-strata (e.g., urban/rural)	
	* (Note that the value of block here is 9 because this capability 
	*  was added after that for blocks 1-8.)	
	if $SHOW_LEVEL_4_ALONE == 1 {
		preserve
		keep if level == 1 & !missing(level4id)
		sort level4order
		forvalues i = 1/`=_N' {
			post to_dataset (name[`i']) (.) `xlist' ///
					(9) (level[`i']) (substratum[`i'])
		}
		restore
		if $SHOW_BLANKS_BETWEEN_LEVELS == 1 `postblankrow' 
	}
	
	* Show each level 2 stratum (sorted in the order the user asked for)
	* and underneath the level 2 row, list one row for each of the level 3
	* strata that are in the level 2 stratum.  e.g., Show a row for each
	* province and then show a row for each district within the province.  
	*
	* After showing all districts for the first province, (optionally) post
	* a blank row and then post results for the next province and its districts
	if $SHOW_LEVELS_2_3_TOGETHER == 1 {
		preserve
		keep if inlist(level,2,3) & missing(level4id)
		sort level2order level3order
		forvalues i = 1/`=_N' {
			if `i' > 1 & level3order[`i'] == 0 `postblankrow'

			post to_dataset (name[`i']) (.) `xlist' ///
					(4) (level[`i']) (substratum[`i'])
		}
		restore
		if $SHOW_BLANKS_BETWEEN_LEVELS == 1 `postblankrow' 
	}

	* Show national results along with the sub-strata (e.g., urban/rural)
	if $SHOW_LEVELS_1_4_TOGETHER == 1 {
		preserve
		keep if inlist(level,1) 
		sort level4order
		forvalues i = 1/`=_N' {
			if `i' > 1 & level4order[`i'] == 0 `postblankrow'

			post to_dataset (name[`i']) (.) `xlist' ///
					(5) (level[`i']) (substratum[`i'])
		}
		restore
		if $SHOW_BLANKS_BETWEEN_LEVELS == 1 `postblankrow' 
	}

	* Show sub-national results along with substrata in each sub-national stratum
	* e.g., each province and then that province's results broken out by 
	* urban/rural
	if $SHOW_LEVELS_2_4_TOGETHER == 1 {
		preserve
		keep if inlist(level,2) 
		sort level2order level4order
		forvalues i = 1/`=_N' {
			if `i' > 1 & level4order[`i'] == 0 `postblankrow'

			post to_dataset (name[`i']) (.) `xlist' ///
					(6) (level[`i']) (substratum[`i'])
		}
		restore
		if $SHOW_BLANKS_BETWEEN_LEVELS == 1 `postblankrow' 
	}
	
	* Show each level 3 stratum and then disaggregate it by the level 4 
	* stratifier (e.g., each district's results and then the district 
	* results broken out by urban/rural
	if $SHOW_LEVELS_3_4_TOGETHER == 1 {
		preserve
		keep if inlist(level,3) 
		sort level3order level4order
		forvalues i = 1/`=_N' {
			if `i' > 1 & level4order[`i'] == 0 `postblankrow'

			post to_dataset (name[`i']) (.) `xlist' ///
					(7) (level[`i']) (substratum[`i'])
		}
		restore
		if $SHOW_BLANKS_BETWEEN_LEVELS == 1 `postblankrow' 
	}
	
	* Show the level 2 stratum results at the top of a block, then break it down
	* urban/rural; then show the first level 3 stratum within the level 2 
	* stratum and break THAT down urban/rural...show the next level 3 stratum
	* and break it down, until all level 3 strata in this level 2 stratum have
	* been listed.  Then skip a row and move on to the next level 2 stratum.
	if $SHOW_LEVELS_2_3_4_TOGETHER == 1 {
		preserve
		keep if inlist(level,2,3) 
		sort level2order level3order level4order
		forvalues i = 1/`=_N' {
			if `i' > 1 & level[`i'] == 2 & level4order[`i'] == 0 `postblankrow'

			post to_dataset (name[`i']) (.) `xlist' ///
					(8) (level[`i']) (substratum[`i'])
		}
		restore
	}

	capture postclose to_dataset
	
	* Now the table should look pretty good in the to_dataset.
	* Do a little housecleaning and then export it to Excel.
	
	* use the local macro 'title' to carry the label of the variable being 
	* summarized
	local title `: variable label outcome'
	
	use "${VCQI_OUTPUT_FOLDER}/`measureid'_${ANALYSIS_COUNTER}_`vid'_TO", clear
	label variable outcome `"`title'"'
	qui compress
	save, replace
	
	*******************************************************
	*
	* Now export the table to Excel
    *
	*
	
	* calculate number of rows in the table
	qui count
	local nrows = r(N)
	
	* for now we leave two blank rows at the top for title and subtitle
	local startrow 3
	local rows 4,`=`startrow'+`nrows''
	
	local nextcolumn 1
	local sheetoption sheetreplace

	* how many variables are being exported?
	local variables = subinstr("`plist'","str25","",.)	
	local variables = subinstr("`variables'","double","",.)	
	local variables stratum `variables' `nlist'
	local nvars = wordcount("`variables'")
			
	* which columns will they be written to?
	local cols `nextcolumn',`=`nextcolumn'+`nvars'-1'
			
	* what is the letter of the first column?
	vcqi_excel_convert_to_letter `nextcolumn'
	
	* what is the cell to put the upper left corner of the new export?
	local cell `r(ConvertToLetter)'`startrow'
				
	* Export the requested variables
	
	export excel `variables' using ///
		"${VCQI_OUTPUT_FOLDER}/${VCQI_ANALYSIS_NAME}_TO.xlsx", ///
		sheet("`sheet'") firstrow(variable) cell(`cell') ///
		`sheetoption'

	* Use mata to populate column labels and worksheet titles and footnotes
	mata: b = xl()
	mata: b.load_book("${VCQI_OUTPUT_FOLDER}/${VCQI_ANALYSIS_NAME}_TO.xlsx")
	mata: b.set_mode("open")
	mata: b.set_sheet("`sheet'")
	
	*Overwrite the stratum variable name...it is not needed
	mata: b.put_string(`startrow',1,"")

	local pcounter 1
	forvalues i = 1/`nvars' {
		
		local col = `nextcolumn' - 1 + `i'
		
		if substr(word("`variables'",`i'),1,1) == "n" & ///
		   substr(word("`variables'",`i'),1,4) != "nwtd" ///
	        mata: b.put_string(`startrow',`col',`"`vlabel`pcounter'' (N)"')

		if substr(word("`variables'",`i'),1,4) == "nwtd" ///
	        mata: b.put_string(`startrow',`col',`"`vlabel`pcounter'' (Weighted N)"')

		if substr(word("`variables'",`i'),1,3) == "pct" {
			mata: b.put_string(`startrow',`col',`"`vlabel`pcounter'' (%)"')
			local ++pcounter
		}
		if substr(word("`variables'",`i'),1,2) == "ci" 	mata: b.put_string(`startrow',`col',`"95% CI (%)"')
		if word("`variables'",`i') == "n" 		 mata: b.put_string(`startrow',`col',`"${`measureid'_N_LABEL}"')
		if word("`variables'",`i') == "nwtd"  	 mata: b.put_string(`startrow',`col',`"${`measureid'_NWTD_LABEL}"')
	}
	
	* If this is the first time we are writing to the worksheet
	* include the measure titles and footnotes
	
	if `nextcolumn' == 1 {
		
		if "${`measureid'_TO_TITLE}" != "" {
			mata: b.put_string(1,1,`"${`measureid'_TO_TITLE}"')
			mata: b.set_font_bold(1,1,"on")
		}
	
		if "${`measureid'_TO_SUBTITLE}" != "" mata: b.put_string(2,1,`"${`measureid'_TO_SUBTITLE}"')

		local footnoterow = `=`startrow'+`nrows'+2'
		local i 1
		while "${`measureid'_TO_FOOTNOTE_`i'}" != "" {
			mata: b.put_string(`footnoterow',1,`"${`measureid'_TO_FOOTNOTE_`i'}"')
			local ++footnoterow
			local ++i
		}
	}
	
	* Usually we'll want to format the excel, but it is time consuming
	* so give an option to turn that off during testing of the code
	if "$FORMAT_EXCEL" == "1" {
	
		* format individual fields to look good
		local pcounter 1
		forvalues i = 1/`nvars' {
		
			local col = `nextcolumn' - 1 + `i'
		
			if word("`variables'",`i') == "stratum"  {
				mata: b.set_column_width(`col',`col', `=`max_stratum_name_length'+3')
				mata: b.set_horizontal_align((`rows'),`col',"left") 
			}

			if substr(word("`variables'",`i'),1,1) == "n" & ///
			   substr(word("`variables'",`i'),1,4) != "nwtd" { 
				local maxcol_width1 = max(5,length(`"`vlabel`pcounter''"')+5)
				mata: b.set_column_width(`col',`col', `maxcol_width1' )
				mata: b.set_horizontal_align((`rows'),`col',"right")
				mata: b.set_number_format((`rows'),`col',"number_sep")
			}
			
			if substr(word("`variables'",`i'),1,4) == "nwtd" { 
				local maxcol_width2 =max(5,length(`"`vlabel`pcounter''"')+14)
				mata: b.set_column_width(`col',`col', `maxcol_width2')
				mata: b.set_horizontal_align((`rows'),`col',"right")
				mata: b.set_number_format((`rows'),`col',"##0.0;;0.0;")
			}
			
			if substr(word("`variables'",`i'),1,3) == "pct" { 
				local maxcol_width3 =max(5,length(`"`vlabel`pcounter''"')+4)
				mata: b.set_column_width(`col',`col', `maxcol_width3')
				mata: b.set_number_format((`rows'),`col',"##0.0;;0.0;")
				local ++pcounter
			}
			
			if substr(word("`variables'",`i'),1,2) == "ci" {
				mata: b.set_column_width(`col',`col', 12)
				mata: b.set_horizontal_align((`rows'),`col',"right")
			}
			
			if word("`variables'",`i') == "n" {
				local nlab_length = max(8,ustrlen(`"${`measureid'_N_LABEL}"')+1)
				mata: b.set_column_width(`col',`col', `nlab_length')													  
				mata: b.set_number_format((`rows'),`col',"number_sep")
			}
			
			if word("`variables'",`i') == "nwtd" {
				local nwtdlab_length = max(12,ustrlen(`"${`measureid'_NWTD_LABEL}"')+1)
				mata: b.set_column_width(`col',`col', `nwtdlab_length')
				mata: b.set_number_format((`rows'),`col',"number_sep")
			}
		}
		
		* right align column titles
		mata: b.set_horizontal_align(`startrow',(`cols'),"right")
		
		* add bold or shading or indent or italics
		forvalues j = 1/`=_N' {
	
			local i = `j' + `startrow'

			if block[`j'] == 4 & ///
			   level[`j'] == 2 ///
			   mata: b.set_fill_pattern(`i',(`cols'),"solid","lightgray")
			
			if block[`j'] == 8 & ///
			   level[`j'] == 2 & ///
			   substratum[`i'] == 0 ///
			   mata: b.set_fill_pattern(`i',(`cols'),"solid","lightgray")
			
			* Indent level 4 stratum names unless they are headings (LABEL_ONLY) with no estimate
			if `nextcolumn' == 1 & substratum[`j'] == 1 & !missing(n[`j']) ///
				mata: b.set_text_indent(`i',`nextcolumn',3)
			if `nextcolumn' == 1 & substratum[`j'] == 1 ///
				mata: b.set_font_italic(`i',`nextcolumn',"on")
			
			if level[`j'] == 1 & ///
				substratum[`j'] == 0 mata: b.set_font_bold(`i',(`cols'),"on")
		}			
		
	}
	
	mata: b.close_book()
		
	vcqi_log_comment $VCP 3 Comment `"Tabular output: `measureid' `: variable label outcome' : `variables' to sheet `sheet' in ${VCQI_OUTPUT_FOLDER}/${VCQI_ANALYSIS_NAME}_TO.xlsx"'	

	vcqi_log_comment $VCP 5 Flow "Exiting"
	global VCP `oldvcp'

end
