*! make_tables_from_unwtd_output version 1.11 - Biostat Global Consulting - 2020-12-12
*******************************************************************************
* Change log
* 				Updated
*				version
* Date 			number 	Name			What Changed
* 2016-01-18	1.01	Dale Rhoda		Changed to vcqi_global
* 2016-02-12	1.02	Dale Rhoda		Add TO to the list of temp datasets
* 										to possibly be deleted later, per the
* 										user's request
* 2016-02-26	1.03	Dale Rhoda		Switch FOOTNOTE code to while loop
* 2016-03-07	1.04	Dale Rhoda		Allow spaces in `sheet' via _nospaces
* 2017-01-30	1.05	Dale Rhoda		Small formatting changes to implement
*										VCQI_LEVEL4_SET_VARLIST & VCQI_LEVEL4_SET_LAYOUT
* 2017-08-26	1.06	Mary Prier		Added version 14.1 line
* 2018-01-16	1.07	Dale Rhoda		The variables option can hold 
*										numerator or estimate or n
* 2018-01-16	1.08	Dale Rhoda		remove old noomitpriorn option
* 2018-11-14	1.09	Dale Rhoda		Added flexible VCQI_NUM_DECIMAL_DIGITS
* 2020-01-15	1.10	MK Trimner		Added double quotes when ustrlen was used for possible labels
*										Created local to pass through the length for col widths
* 2020-12-12	1.11	Dale Rhoda		Allow user to SHOW_LEVEL_4_ALONE
*******************************************************************************

program define make_tables_from_unwtd_output
	version 14.1
	
	syntax  , VID(string) MEASureid(string) SHEET(string) ///
			  [ RATIO NUMERLABEL(string asis) ///
			    NLABEL(string asis) VARiables(string) ESTLABel(string asis) ]
				
	local oldvcp $VCP
	global VCP make_tables_from_unwtd_output
	vcqi_log_comment $VCP 5 Flow "Starting"
	
	quietly {

		local sheet_nospaces = subinstr("`sheet'"," ","_",.)
		local sheet_nospaces = subinstr("`sheet_nospaces'","-","_",.)

		vcqi_log_comment $VCP 5 Flow "Starting"	
		if "$VCQI_DEBUG" == "1" vcqi_log_comment $VCP 3 Comment "Worksheet = `sheet'"
		if "$VCQI_DEBUG" == "1" vcqi_log_comment $VCP 3 Comment "Measure = `measureid'"
		if "$VCQI_DEBUG" == "1" vcqi_log_comment $VCP 3 Comment "Variables = `variables'"
		if "$VCQI_DEBUG" == "1" vcqi_log_comment $VCP 3 Comment "Label = `estlabel'"
		if "$VCQI_DEBUG" == "1" vcqi_log_comment $VCP 3 Comment "VID = `vid'"
		if "$VCQI_DEBUG" == "1" vcqi_log_comment $VCP 3 Comment "Ratio = `ratio'"
		if "$VCQI_DEBUG" == "1" vcqi_log_comment $VCP 3 Comment "Nlabel = `nlabel'"
		if "$VCQI_DEBUG" == "1" vcqi_log_comment $VCP 3 Comment "Numerlabel = `numerlabel'"
		
		* This program does several things...
		*
		* 1. It reads in the results generated by GO and tidies them up.
		* 2. It parses out what order the user wants to see stratum-level
		*    results in the spreadsheets.
		* 3. Then it writes (posts) the output to a new dataset in a format
		*    that looks like the tables...in the correct order and with
		*    blank rows, etc.  Nothing is formatted, but at this point it
		*    is staged for export to Excel.
		* 4. Then the program writes the table out to Excel and does some
		*    basic formatting.
		*
		*   
		*  (This sounds like too many jobs for one program, so consider
		*   coming back and breaking it into smaller pieces.)
		
		* Open the post file with the handle name "to_dataset" (tabulated output)
		*
		* the three fields at the end: block level and substratum
		* are not meant to be written out, but are handy for formatting the 
		* spreadsheet cells
		*
		
		capture postclose to_dataset

		postfile to_dataset str50 stratum  estimate n block level substratum ///
					using ///
					"${VCQI_OUTPUT_FOLDER}/`measureid'_${ANALYSIS_COUNTER}_`vid'_TO", replace

		global `measureid'_TEMP_DATASETS ${`measureid'_TEMP_DATASETS} `measureid'_${ANALYSIS_COUNTER}_`vid'_TO

		use "${VCQI_OUTPUT_FOLDER}/`measureid'_${ANALYSIS_COUNTER}_`vid'_database", clear
		
		* Preparatory work and tidying of variables	
		
		* calculate maximum number of characters in the stratum name
		gen stratum_name_length = ustrlen(name)
		qui summarize stratum_name_length
		local max_stratum_name_length = r(max)
		drop stratum_name_length
		
		* scale estimate figures up by 100x if this is a percent and not a ratio
		replace estimate = estimate * 100 if "`ratio'" != "ratio"
		
		replace n = round(n,1)
		
		* generate a new 0/1 flag that indicates which rows in the output 
		* are showing results for sub-strata defined by level 4
		
		gen substratum = !missing(level4id)
		
		* bring in information about what order the user wants to list rows from
		* levels 2, 3, and 4.  If the user has NOT specifed datasets with sort 
		* order, then they are simply listed in numerical or alphabetical order 
		* of their respective ids
		
		if "$LEVEL2_ORDER_DATASET" != "" {
			merge m:1 level2id using "$LEVEL2_ORDER_DATASET"
			keep if _merge == 1 | _merge == 3
			drop _merge
			order level2order, after(level2id)
		}
		else {
			gen level2order = level2id
		}
		replace level2order = 0 if missing(level2order)
		
		if "$LEVEL3_ORDER_DATASET" != "" {
			merge m:1 level3id using "$LEVEL3_ORDER_DATASET"
			keep if _merge == 1 | _merge == 3
			drop _merge
			order level3order, after(level3id)
		}
		else {
			gen level3order = level3id
		}
		replace level3order = 0 if missing(level3order)

		if "$VCQI_LEVEL4_STRATIFIER" != "" & "$LEVEL4_ORDER_DATASET" != "" {
			merge m:1 level4id using "$LEVEL4_ORDER_DATASET"
			keep if _merge == 1 | _merge == 3
			drop _merge
		}
		else if "$VCQI_LEVEL4_SET_LAYOUT" != "" & "$LEVEL4_ORDER_DATASET" != "" {
			* Use the level4_layout order as the level4order
			gen level4order = int(level4id)
		}
		else {
			gen level4order = level4id
		}
		replace level4order = 0 if missing(level4order)
		order level4order, after(level4id)
		
		***********************************************************
		*
		* Now we have eight blocks of code to generate different 
		* types of blocks of output.  The user might select only
		* one of these, or a subset.  It would probably be unusual 
		* to ask for all 8 blocks to be put out, as that would be
		* quite repetitive, but the code will happily do it if the
		* user asks for it.
		*
		* What people select will depend on what they are doing
		* with the tables and what sort of detail they want.
		*
		***********************************************************

		* In many cases the output tables will be easier to read if they
		* have a blank row between blocks and even within blocks between
		* large strata.  If the user asks for blanks between levels, then
		* we set up an empty post command to put out an empty row.
		*
		* Store the command in a local macro so we can call it later by
		* simply saying `postblankrow'.
		
		if $SHOW_BLANKS_BETWEEN_LEVELS == 1 {
			local postblankrow post to_dataset ("") (.) (.) (.) (.) (.)
		}
		if $SHOW_BLANKS_BETWEEN_LEVELS == 0 {
			local postblankrow local noblankrows
		}

		* Only show results that are aggregated up to the national level (1)
		if $SHOW_LEVEL_1_ALONE == 1 {
			preserve 
			keep if level == 1 & missing(level4id)
			local i 1
			post to_dataset (name[`i']) (estimate[`i']) (n[`i'])  ///
					(1) (1) (0)
			restore
			if $SHOW_BLANKS_BETWEEN_LEVELS == 1 `postblankrow' 
		}
		
		* In this block we only show the sub-national or province level (2) results
		if $SHOW_LEVEL_2_ALONE == 1 {
			preserve
			keep if level == 2 & missing(level4id)
			sort level2order
			forvalues i = 1/`=_N' {
				post to_dataset (name[`i']) (estimate[`i']) (n[`i'])  ///
						(2) (level[`i']) (substratum[`i'])
			}
			restore
			if $SHOW_BLANKS_BETWEEN_LEVELS == 1 `postblankrow' 
		}
			
		* Only show the sub-sub-national level (3) without aggregating upward	
		if $SHOW_LEVEL_3_ALONE == 1 {
			preserve
			keep if level == 3 & missing(level4id)
			sort level3order
			forvalues i = 1/`=_N' {
				post to_dataset (name[`i']) (estimate[`i']) (n[`i'])  ///
						(3) (level[`i']) (substratum[`i'])
			}
			restore
			if $SHOW_BLANKS_BETWEEN_LEVELS == 1 `postblankrow' 
		}
		
		* Only show the sub-strata (e.g., urban/rural)	
		* (Note that the value of block here is 9 because this capability 
		*  was added after that for blocks 1-8.)
		if $SHOW_LEVEL_4_ALONE == 1 {
			preserve
			keep if level == 1 & !missing(level4id)
			sort level4order
			forvalues i = 1/`=_N' {
				post to_dataset (name[`i']) (estimate[`i']) (n[`i'])  ///
						(9) (level[`i']) (substratum[`i'])
			}
			restore
			if $SHOW_BLANKS_BETWEEN_LEVELS == 1 `postblankrow' 
		}
	
		* Show each level 2 stratum (sorted in the order the user asked for)
		* and underneath the level 2 row, list one row for each of the level 3
		* strata that are in the level 2 stratum.  e.g., Show a row for each
		* province and then show a row for each district within the province.  
		*
		* After showing all districts for the first province, (optionally) post
		* a blank row and then post results for the next province and its districts
		if $SHOW_LEVELS_2_3_TOGETHER == 1 {
			preserve
			keep if inlist(level,2,3) & missing(level4id)
			sort level2order level3order
			forvalues i = 1/`=_N' {
				if `i' > 1 & level3order[`i'] == 0 `postblankrow'

				post to_dataset (name[`i']) (estimate[`i']) (n[`i']) ///
						(4) (level[`i']) (substratum[`i'])
			}
			restore
			if $SHOW_BLANKS_BETWEEN_LEVELS == 1 `postblankrow' 
		}

		* Show national results along with the sub-strata (e.g., urban/rural)
		if $SHOW_LEVELS_1_4_TOGETHER == 1 {
			preserve
			keep if inlist(level,1) 
			sort level4order
			forvalues i = 1/`=_N' {
				if `i' > 1 & level4order[`i'] == 0 `postblankrow'

				post to_dataset (name[`i']) (estimate[`i']) (n[`i']) ///
						(5) (level[`i']) (substratum[`i'])
			}
			restore
			if $SHOW_BLANKS_BETWEEN_LEVELS == 1 `postblankrow' 
		}

		* Show sub-national results along with substrata in each sub-national stratum
		* e.g., each province and then that province's results broken out by 
		* urban/rural
		if $SHOW_LEVELS_2_4_TOGETHER == 1 {
			preserve
			keep if inlist(level,2) 
			sort level2order level4order
			forvalues i = 1/`=_N' {
				if `i' > 1 & level4order[`i'] == 0 `postblankrow'

				post to_dataset (name[`i']) (estimate[`i']) (n[`i'])  ///
						(6) (level[`i']) (substratum[`i'])
			}
			restore
			if $SHOW_BLANKS_BETWEEN_LEVELS == 1 `postblankrow' 
		}
		
		* Show each level 3 stratum and then disaggregate it by the level 4 
		* stratifier (e.g., each district's results and then the district 
		* results broken out by urban/rural
		if $SHOW_LEVELS_3_4_TOGETHER == 1 {
			preserve
			keep if inlist(level,3) 
			sort level3order level4order
			forvalues i = 1/`=_N' {
				if `i' > 1 & level4order[`i'] == 0 `postblankrow'

				post to_dataset (name[`i']) (estimate[`i']) (n[`i']) ///
						(7) (level[`i']) (substratum[`i'])
			}
			restore
			if $SHOW_BLANKS_BETWEEN_LEVELS == 1 `postblankrow' 
		}
		
		* Show the level 2 stratum results at the top of a block, then break it down
		* urban/rural; then show the first level 3 stratum within the level 2 
		* stratum and break THAT down urban/rural...show the next level 3 stratum
		* and break it down, until all level 3 strata in this level 2 stratum have
		* been listed.  Then skip a row and move on to the next level 2 stratum.
		if $SHOW_LEVELS_2_3_4_TOGETHER == 1 {
			preserve
			keep if inlist(level,2,3) 
			sort level2order level3order level4order
			forvalues i = 1/`=_N' {
				if `i' > 1 & level[`i'] == 2 & level4order[`i'] == 0 `postblankrow'

				post to_dataset (name[`i']) (estimate[`i']) (n[`i']) ///
						(8) (level[`i']) (substratum[`i'])
			}
			restore
		}

		capture postclose to_dataset
		
		* Now the table should look pretty good in the to_dataset.
		* Do a little housecleaning and then export it to Excel.
		
		use "${VCQI_OUTPUT_FOLDER}/`measureid'_${ANALYSIS_COUNTER}_`vid'_TO", clear
		qui compress
		* Re-calculate the integer numerator, using estimate and denominator
		gen numerator = round(estimate*n/100)
		
		* Label the variables
		if "`estlabel'" == "" local estlabel Estimate
		if "`numerlabel'" == "" local numerlabel Numerator
		if "`nlabel'"   == "" local nlabel   N
		label variable numerator "`numerlabel'"
		label variable n "`nlabel'"
		label variable estimate "`estlabel'"
		
		save, replace
		
		*******************************************************
		*
		* Export to Excel
		*
		
		* calculate number of rows in the table
		qui count
		local nrows = r(N)
		
		* for now we leave two blank rows at the top for title and subtitle
		local startrow 3
		local rows 4,`=`startrow'+`nrows''
		
		if "$VCQI_DEBUG" == "1" vcqi_log_comment $VCP 3 Comment "LAST_COL full == ${LC4_`sheet_nospaces'}"
		
		* check for a valid list of variables
		
		if "`variables'" == "" local variables estimate n
				
		foreach v in `variables' {
			if !inlist("`v'","estimate","numerator","n") {
				di as error "make_tables_from_unwtd_output.ado: The variable `v' contains a word that is not one of the output options."
				di as error "Options include: estimate, numerator and n."
				vcqi_log_comment $VCP 1 Error  "make_tables_from_unwtd_output.ado: The variable `v' is not one of the output options."
				vcqi_log_comment $VCP 1 Error  "Options include: estimate, numerator and n."
				vcqi_halt_immediately
			}
		}		
		
		* If we have not yet written to this tab, be sure to include the
		* stratum names in the output, and start at column 1
		if "${LC4_`sheet_nospaces'}" == "" {
			local vlist stratum `variables' 
			local nextcolumn 1
			local sheetoption sheetreplace
			local stratum	1
			forvalues i = 1/`=wordcount("`variables'")' {
				local `=word("`variables'",`i')'  `= 1 + `i''
			}
		}
		* If we have already written something to this tab, then we do not
		* need to repeat the stratum names;  
		*
		 
		else {
			local vlist `variables'
			
			local nextcolumn = ${LC4_`sheet_nospaces'} + 1
			
			local sheetoption sheetmodify
			forvalues i = 1/`=wordcount("`variables'")' {
				local `=word("`variables'",`i')'  `= `nextcolumn' + `i' -1'
			}
		}
		
		local ncols = wordcount("`vlist'")
		
		if "$VCQI_DEBUG" == "1" vcqi_log_comment $VCP 3 Comment "vlist = `vlist'"
		
		local cols `nextcolumn',`= `nextcolumn' + `ncols' -1 '
				
		vcqi_excel_convert_to_letter `nextcolumn'
		
		local cell `r(ConvertToLetter)'`startrow'
		
		if "$VCQI_DEBUG" == "1" vcqi_log_comment $VCP 3 Comment "cell = `cell'"
				
		* Export the brief table to an Excel worksheet.  The user specifies the
		* name of the worksheet.
		
		export excel `vlist' using "${VCQI_OUTPUT_FOLDER}/${VCQI_ANALYSIS_NAME}_TO.xlsx", ///
			sheet("`sheet'") firstrow(variable) cell(`cell') `sheetoption'

		if "${LC4_`sheet_nospaces'}" == "" {
			vcqi_global LC4_`sheet_nospaces' `ncols'
		}
		else {
			vcqi_global LC4_`sheet_nospaces' `= ${LC4_`sheet_nospaces'} + `ncols' '
		}	
		
		mata: b = xl()
		mata: b.load_book("${VCQI_OUTPUT_FOLDER}/${VCQI_ANALYSIS_NAME}_TO.xlsx")
		mata: b.set_mode("open")
		mata: b.set_sheet("`sheet'")
		
		*Overwrite the stratum variable name...it is not needed
		mata: b.put_string(`startrow',1,"")

		forvalues i = 1/`ncols' {
			if word("`vlist'",`i') == "estimate"  mata: b.put_string(`startrow',`estimate', "`estlabel'")
			if word("`vlist'",`i') == "numerator" mata: b.put_string(`startrow',`numerator',"`numerlabel'")
			if word("`vlist'",`i') == "n"         mata: b.put_string(`startrow',`n',        "`nlabel'")
		}
		
		if `nextcolumn' == 1 {
					
			if "$`measureid'_TO_TITLE"    != "" {
				mata: b.put_string(1,1,"$`measureid'_TO_TITLE")
				mata: b.set_font_bold(1,1,"on")
			}
			if "${`measureid'_TO_SUBTITLE}" != "" mata: b.put_string(2,1,"${`measureid'_TO_SUBTITLE}")

			local footnoterow = `=`startrow'+`nrows'+2'
			local i 1
			while "${`measureid'_TO_FOOTNOTE_`i'}" != "" {
				mata: b.put_string(`footnoterow',1,"${`measureid'_TO_FOOTNOTE_`i'}")
				local ++footnoterow
				local ++i
			}
		}
		
		if "$FORMAT_EXCEL" == "1" {
			if $VCQI_NUM_DECIMAL_DIGITS == 0 local dp 
			if $VCQI_NUM_DECIMAL_DIGITS > 0 {
				local dp .
				forvalues i = 1/$VCQI_NUM_DECIMAL_DIGITS {
					local dp `dp'0
				}
			}
			if $VCQI_NUM_DECIMAL_DIGITS < 0 local dp .0
								
			if `nextcolumn' == 1 mata: b.set_column_width(`stratum',`stratum', `=`max_stratum_name_length'+3')
			if `nextcolumn' == 1 mata: b.set_horizontal_align((`rows'),`stratum',"left")

			forvalues i = 1/`ncols' {

				if word("`vlist'",`i') == "estimate"  {
					local estlabel_length = max(5,ustrlen(`"`estlabel'"')+1)
					mata: b.set_column_width(`estimate',`estimate', `estlabel_length')
					if "`ratio'" != "ratio" mata: b.set_number_format((`rows'),`estimate',"##`dp';;`dp';")
					if "`ratio'" == "ratio" mata: b.set_number_format((`rows'),`estimate',"##0.000;;0.0;")
				}
			
				if word("`vlist'",`i') == "numerator" {
					local numlabel_length = max(8,ustrlen(`"`numerlabel'"')+1)
					mata: b.set_column_width(`numerator',`numerator' , `numlabel_length')
					mata: b.set_number_format((`rows'),  `numerator' , "number_sep")
				}
				
				if word("`vlist'",`i') == "n" {
					local nlabel_length = max(8,ustrlen(`"`nlabel'"')+1)
					mata: b.set_column_width(`n',`n' , `nlabel_length')
					mata: b.set_number_format((`rows'), `n' , "number_sep")
				}
			}
		
			mata: b.set_horizontal_align(`startrow',(`cols'),"right")
			
			* add bold or shading or indent or italics
			forvalues j = 1/`=_N' {
		
				local i = `j' + `startrow'

				if block[`j'] == 4 & ///
				   level[`j'] == 2 ///
				   mata: b.set_fill_pattern(`i',(`cols'),"solid","lightgray")
				
				if block[`j'] == 8 & ///
				   level[`j'] == 2 & ///
				   substratum[`i'] == 0 ///
				   mata: b.set_fill_pattern(`i',(`cols'),"solid","lightgray")
				
				* Indent level 4 stratum names unless they are headings (LABEL_ONLY) with no estimate
				if `nextcolumn' == 1 & substratum[`j'] == 1 & !missing(estimate[`j']) ///
					mata: b.set_text_indent(`i',`nextcolumn',3)
				if `nextcolumn' == 1 & substratum[`j'] == 1 ///
					mata: b.set_font_italic(`i',`nextcolumn',"on")
				
				if level[`j'] == 1 & ///
					substratum[`j'] == 0 mata: b.set_font_bold(`i',(`cols'),"on")
			}	
		}		
		
		mata: b.close_book()
		
		vcqi_log_comment $VCP 3 Comment "Tabular output from: `measureid'_${VCQI_ANALYSIS_COUNTER}_`vid' to sheet `sheet' in ${VCQI_OUTPUT_FOLDER}/${VCQI_ANALYSIS_NAME}_TO.xlsx"	
	}
	
	vcqi_log_comment $VCP 5 Flow "Exiting"
	global VCP `oldvcp'

end
